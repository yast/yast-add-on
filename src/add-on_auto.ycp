/**
 * File:
 *      add-on_auto.ycp
 *
 * Module:
 *      Add-On autoinstallation and configuration
 *
 * Summary:
 *      Add-On autoinstallation preparation
 *
 * Authors:
 *      Jiri Srain <jsrain@suse.cz>
 *
 * $Id:$
 *
 */
{
textdomain "add-on";

y2milestone("----------------------------------------");
y2milestone("add-on auto started");

import "AddOnProduct";
import "Progress";
import "AutoinstSoftware";
import "PackageCallbacksInit";
import "Label";
import "AutoinstGeneral";
import "PackageLock";
import "Installation";
import "String";

include "add-on/add-on-workflow.ycp";

boolean progress_orig = Progress::set (false);


any ret = nil;
string func = "";
map param = $[];

/* Check arguments */
if(size((list)WFM::Args()) > 0 && is(WFM::Args(0), string)) {
    func = (string)WFM::Args(0);
    if(size((list)WFM::Args()) > 1 && is(WFM::Args(1), map))
	param = (map)WFM::Args(1);
}
y2debug("func=%1", func);
y2debug("param=%1", param);

if(func == "Import")
{
    ret = AddOnProduct::Import((map<string,any>)param);
}
/**
 * Create a summary
 * return string
 */
else if(func == "Summary") {
    ret = "<ul>\n";
    foreach (map<string,any> prod, AddOnProduct::add_on_products, {
	ret = (string)ret + sformat (_("<li>Media: %1, Path: %2, Product: %3</li>\n"),
	    prod["media_url"]:"",
	    prod["product_dir"]:"/",
	    prod["product"]:""
	);
    });
    ret = (string)ret + "</ul>";
}
/**
 * did configuration changed
 * return boolean
*/
else if (func == "GetModified") {
    ret = AddOnProduct::modified;
}
/**
 * set configuration as changed
 * return boolean
 */
else if (func == "SetModified") {
    AddOnProduct::modified = true;
    ret = true;
}
/**
 * Reset configuration
 * return map or list
 */
else if (func == "Reset") {
    AddOnProduct::add_on_products = [];
    ret = $[];
}

/**
 * Change configuration
 * return symbol (i.e. `finish || `accept || `next || `cancel || `abort)
 */
else if (func == "Change") {
    Wizard::CreateDialog ();
    AutoinstSoftware::pmInit ();
    PackageCallbacksInit::InitPackageCallbacks ();
    ret = RunAddOnMainDialog (
	false, true, true,
	Label::BackButton(), Label::OKButton(), Label::CancelButton(),
	false
    );
    UI::CloseDialog ();
    return ret;
}
/**
 * Return configuration data
 * return map or list
 */
else if (func == "Export") {
    ret = AddOnProduct::Export();
}
/**
 * Write configuration data
 * return boolean
 *
 * @struct
 * <add-on>
 *	<add_on_products config:type="list">
 *		<listentry>
 *			<media_url>http://software.opensuse.org/download/server:/dns/SLE_10/</media_url>
 *			<product>buildservice</product>
 *			<product_dir>/</product_dir>
 *			<!-- (optional) -->
 *			<name>User-Defined Product Name</name>
 *			<signature-handling>
 *				<accept_unsigned_file config:type="boolean">true</accept_unsigned_file>
 *				<accept_file_without_checksum config:type="boolean">true</accept_file_without_checksum>
 *				<accept_verification_failed config:type="boolean">true</accept_verification_failed>
 *				<accept_unknown_gpg_key>
 *					<all config:type="boolean">true</all>
 *					<keys config:type="list">
 *						<keyid>...</keyid>
 *						<keyid>3B3011B76B9D6523</keyid>
 *					</keys>
 *				</accept_unknown_gpg_key>
 *				<accept_non_trusted_gpg_key>
 *				<all config:type="boolean">true</all>
 *					<keys config:type="list">
 *						<keyid>...</keyid>
 *					</keys>
 *				</accept_non_trusted_gpg_key>
 *				<import_gpg_key>
 *					<all config:type="boolean">true</all>
 *					<keys config:type="list">
 *						<keyid>...</keyid>
 *					</keys>
 *				</import_gpg_key>
 *			</signature-handling>
 *		</listentry>
 *	</add_on_products>
 * </add-on>
 *
 */
else if (func == "Write") {
    map <string, map <string, integer> > sources = $[];

    AddOnProduct::add_on_products = maplist (map <string, any> prod, AddOnProduct::add_on_products, {
	string media = prod["media_url"]:"";
	string pth = prod["product_dir"]:"/";

	if (String::StartsWith(media, "relurl://"))
	{
		string base = AddOnProduct::GetBaseProductURL();
		media = AddOnProduct::GetAbsoluteURL( base, media );
		y2milestone("relurl changed to %1", media);
	}

	sources[media] = sources[media]:$[];

	// set addon specific sig-handling
        AddOnProduct::SetSignatureCallbacks (prod["product"]:"");

	integer srcid = -1;

	do {
	    string url = AddOnProduct::SetRepoUrlAlias(media, prod["alias"]:"", prod["name"]:"");

	    srcid = Pkg::SourceCreate(url, pth);

	    if ((srcid == -1 || srcid == nil) && !prod["ask_on_error"]:false) {
		// error report
		Report::Error (_("Failed to add add-on product."));
	    } else if( (srcid == -1 || srcid == nil) && prod["ask_on_error"]:false) {
		prod["ask_on_error"] = Popup::ContinueCancel (
		    sformat (_("Please make the add-on \"%1\" available via \"%2\""), prod["product"]:"", media)
		);
	    }

	    sources[media, pth] = srcid;
	    y2milestone ("New source ID: %1", srcid);

	    // bugzilla #260613
	    if (srcid != -1)
		AddOnProduct::Integrate (srcid);

	    // reset to global sig-handling
            AutoinstGeneral::SetSignatureHandling();

	} while (sources[media, pth]:-1 == -1 && prod["ask_on_error"]:false == true);

	prod["media"] = sources[media, pth]:-1;

	// Adjust "name", bnc #434708
	if (srcid != nil && srcid != -1) {
	    list <map <string, any> > repos = Pkg::SourceEditGet();

	    integer found_at = -1;
	    integer counter = -1;

	    foreach (map one_repo, repos, {
		counter = counter + 1;
		if (one_repo["SrcId"]:-1 == srcid) {
		    found_at = counter;
		    break;
		}
	    });

	    if (found_at != -1) {
		string name = repos[found_at, "name"]:"";

		// Possibility to set name in control file, bnc #433981
		if (haskey (prod, "name")) {
		    name = prod["name"]:"";
		    y2milestone ("Preferred name: %1", name);
		// Or use the one returned by Pkg::RepositoryScan
		} else {
		    list <list <string> > repos_at_url = Pkg::RepositoryScan (media);
		    // [ ["Product Name", "Path" ] ]
		    foreach (list <string> one_repo, repos_at_url, {
			if (one_repo[1]:"" == pth) {
			    name = one_repo[0]:"";
			    break;
			}
		    });
		    y2milestone ("Preferred name: %1", name);
		}

		repos[found_at, "name"] = name;
		Pkg::SourceEditSet (repos);
	    }
	}

	if (prod["product"]:"" != "") {
	    y2milestone ("Installing product: %1", prod["product"]:"");
	    Pkg::ResolvableInstall (prod["product"]:"", `product);
	} else {
	    y2warning ("No product to install");
	}
    });

    // reread agents, redraw wizard steps, etc.
    AddOnProduct::ReIntegrateFromScratch();

    ret = true;
}
/**
 * Reads configuration of add-ons from the current system
 * to memory. To get that configuration, use Export() functionality.
 *
 * @returns boolean
 */
else if (func == "Read") {
    if (! PackageLock::Check()) {
	y2error ("Cannot get package lock");
	return false;
    }
    y2milestone ("Reseting Pkg");
    Pkg::PkgApplReset();
    Pkg::PkgReset();

    Pkg::TargetInitialize (Installation::destdir);
    Pkg::TargetLoad();
    Pkg::SourceStartManager (true);
    Pkg::PkgSolve (true);

    ret = ReadFromSystem();
}
/* unknown function */
else {
    y2error("unknown function: %1", func);
    ret =  false;
}
Progress::set (progress_orig);

y2debug("ret=%1", ret);
y2milestone("add-on_auto finished");
y2milestone("----------------------------------------");

return ret;

/* EOF */

}
