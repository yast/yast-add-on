/**
 * File:	clients/inst_add-on.ycp
 * Package:	yast2-add-on
 * Summary:	Select add-on products for installation
 * Authors:	Jiri Srain <jsrain@suse.de>
 *
 */

{
textdomain "add-on";

import "AddOnProduct";
import "GetInstArgs";
import "Packages";
import "PackageCallbacksInit";
import "Popup";
import "ProductControl";
import "Report";
import "Wizard";
import "Label";
import "Installation";
import "Linuxrc";
import "String";

include "add-on/add-on-workflow.ycp";

/*
 * Ask to user to configure network for installing remote addons.
 * User is aske when there is a remote add-on found and the network
 * is not running yet.
 *
 * @param addon_urls list of URLs
 * @return symbol user input result (`next, `back or `abort)
 */
symbol NetworkSetupForAddons(list<string> addon_urls)
{
    // protocols locally available (no network needed)
    const list<string> local_protocols = ["cd", "dvd", "hd"];

    // is this CD/DVD/HDD installation?
    if (contains(local_protocols, tolower(Linuxrc::InstallInf("InstMode"))))
    {
        // is there any remote addon requiring network setup?
        boolean network_needed = false;
        foreach(string url, addon_urls,
            {
                // is it a remote protocol?
                if (!contains(local_protocols, tolower(URL::Parse(url)["scheme"]:"")))
                {
                    network_needed = true;
                    break;
                }
            }
        );

        if (network_needed)
        {
            // check and setup network
            symbol ret = (symbol) WFM::CallFunction("inst_network_check", []);
            y2milestone ("inst_network_check ret: %1", ret);

            if (contains ([`back, `abort], ret)) {
                return ret;
            }
        }
    }

    return `next;
}

if (AddOnProduct::skip_add_ons) {
    y2milestone ("Skipping add-ons (as requested before)");
    return `auto;
}

map argmap = GetInstArgs::argmap();

Packages::SelectProduct ();

PackageCallbacksInit::SetMediaCallbacks();

// add add-ons specified on the kernel command line
string addon_opt = Linuxrc::InstallInf("addon");

// add the add-ons just once, skip adding if any add-on is
// already present (handle going back and forth properly)
if (addon_opt != nil && AddOnProduct::add_on_products == []) {
    y2milestone("Specified extra add-ons via kernel cmdline");

    // store the add-ons list into a temporary file
    string tmp_dir = (string) SCR::Read(.target.tmpdir);
    string tmp_file = tmp_dir + "/tmp_addon_list";
    // each add-on on a separate line
    string addons = String::Replace(addon_opt, ",", "\n");

    // network setup is needed for CD/DVD/HDD installation with remote Add-ons
    symbol ret = NetworkSetupForAddons(splitstring(addons, "\n"));

    if (contains ([`back, `abort], ret)) {
        return ret;
    }

    SCR::Write(.target.string, tmp_file, addons);

    // import the add-ons from the temporary file
    AddOnProduct::AddPreselectedAddOnProducts([$["file" : tmp_file, "type" : "plain"]]);

    // remove the temporary file
    SCR::Execute(.target.bash, sformat ("/bin/rm -rf '%1'", String::Quote(tmp_file)));
}

// the module was started because of the kernel command line option
// so finish it after adding the add-ons, no UI is actually needed
if (Installation::add_on_selected == false) {
    return `auto;
}

symbol ret = RunAddOnMainDialog (
    GetInstArgs::enable_back(), GetInstArgs::enable_next(), true,
    Label::BackButton(), Label::NextButton(), Label::AbortButton(),
    true
);

if (ret == `next)
{
    ret = ProductControl::RunFrom (
	ProductControl::CurrentStep () + 1,
	true);
    if (ret == `next)
	ret = `finish;
}

return ret;

/* EOF */
}
